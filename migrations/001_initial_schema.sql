-- Pierre Fashion Platform - Initial Database Schema Migration
-- Migration: 001_initial_schema
-- Created: 2025-06-13
-- Description: Creates all core tables for the Pierre fashion platform

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- PROFILES TABLE
-- ============================================================================
-- User profiles linked to Supabase Auth users
CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL,
    updated_at timestamp with time zone NULL,
    name text NULL,
    gender text NULL,
    positive_brands text[] NOT NULL DEFAULT '{}',
    negative_brands text[] NOT NULL DEFAULT '{}',
    positive_styles text[] NOT NULL DEFAULT '{}',
    negative_styles text[] NOT NULL DEFAULT '{}',
    positive_colors text[] NOT NULL DEFAULT '{}',
    negative_colors text[] NOT NULL DEFAULT '{}',
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    
    CONSTRAINT profiles_pkey PRIMARY KEY (id),
    CONSTRAINT profiles_id_fkey FOREIGN KEY (id) 
        REFERENCES auth.users (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- ============================================================================
-- PRODUCTS TABLE
-- ============================================================================
-- Products catalog from various brands
CREATE TABLE IF NOT EXISTS public.products (
    id text NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    type text NULL,
    search_query text NULL,
    link text NULL,
    title text NULL,
    price text NULL,
    images text[] NULL,
    brand text NULL,
    description text NULL,
    
    CONSTRAINT products_pkey PRIMARY KEY (id),
    CONSTRAINT products_product_id_key UNIQUE (id)
) TABLESPACE pg_default;

-- ============================================================================
-- OUTFITS TABLE
-- ============================================================================
-- Generated outfit concepts
CREATE TABLE IF NOT EXISTS public.outfits (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    title text NULL,
    description text NULL,
    image_url text NULL,
    user_prompt text NULL,
    
    CONSTRAINT outfits_pkey PRIMARY KEY (id)
) TABLESPACE pg_default;

-- ============================================================================
-- JUNCTION TABLES
-- ============================================================================
-- Many-to-many relationship between products and outfits
CREATE TABLE IF NOT EXISTS public.product_outfit_junction (
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    outfit_id bigint NOT NULL,
    product_id text NOT NULL,
    
    CONSTRAINT product_outfit_junction_pkey PRIMARY KEY (outfit_id, product_id),
    CONSTRAINT product_outfit_junction_outfit_id_fkey 
        FOREIGN KEY (outfit_id) REFERENCES public.outfits (id) ON DELETE CASCADE,
    CONSTRAINT product_outfit_junction_product_id_fkey 
        FOREIGN KEY (product_id) REFERENCES public.products (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- ============================================================================
-- USER INTERACTION TABLES
-- ============================================================================
-- User likes for outfits
CREATE TABLE IF NOT EXISTS public.user_outfit_likes (
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    outfit_id bigint NOT NULL,
    user_id uuid NOT NULL,
    
    CONSTRAINT user_outfit_likes_pkey PRIMARY KEY (outfit_id, user_id),
    CONSTRAINT user_outfit_likes_outfit_id_fkey 
        FOREIGN KEY (outfit_id) REFERENCES public.outfits (id) ON DELETE CASCADE,
    CONSTRAINT user_outfit_likes_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES public.profiles (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- User dislikes for outfits
CREATE TABLE IF NOT EXISTS public.user_outfit_dislikes (
    id bigint GENERATED BY DEFAULT AS IDENTITY NOT NULL,
    created_at timestamp with time zone NOT NULL DEFAULT now(),
    user_id uuid NULL,
    outfit_id bigint NULL,
    
    CONSTRAINT user_outfit_dislikes_pkey PRIMARY KEY (id),
    CONSTRAINT user_outfit_dislikes_outfit_id_fkey 
        FOREIGN KEY (outfit_id) REFERENCES public.outfits (id) ON DELETE CASCADE,
    CONSTRAINT user_outfit_dislikes_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES public.profiles (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- User likes for individual products
CREATE TABLE IF NOT EXISTS public.user_product_likes (
    user_id uuid NOT NULL,
    product_id text NOT NULL,
    created_at timestamp without time zone NULL DEFAULT now(),
    
    CONSTRAINT user_product_likes_pkey PRIMARY KEY (user_id, product_id),
    CONSTRAINT user_product_likes_product_id_fkey 
        FOREIGN KEY (product_id) REFERENCES public.products (id) ON DELETE CASCADE,
    CONSTRAINT user_product_likes_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES public.profiles (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- User dislikes for individual products
CREATE TABLE IF NOT EXISTS public.user_product_dislikes (
    user_id uuid NOT NULL,
    product_id text NOT NULL,
    created_at timestamp without time zone NULL DEFAULT now(),
    
    CONSTRAINT user_product_dislikes_pkey PRIMARY KEY (user_id, product_id),
    CONSTRAINT user_product_dislikes_product_id_fkey 
        FOREIGN KEY (product_id) REFERENCES public.products (id) ON DELETE CASCADE,
    CONSTRAINT user_product_dislikes_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES public.profiles (id) ON DELETE CASCADE
) TABLESPACE pg_default;

-- ============================================================================
-- INDEXES FOR PERFORMANCE
-- ============================================================================
-- Indexes for better query performance
CREATE INDEX IF NOT EXISTS idx_profiles_created_at ON public.profiles(created_at);
CREATE INDEX IF NOT EXISTS idx_products_created_at ON public.products(created_at);
CREATE INDEX IF NOT EXISTS idx_products_type ON public.products(type);
CREATE INDEX IF NOT EXISTS idx_products_brand ON public.products(brand);
CREATE INDEX IF NOT EXISTS idx_outfits_created_at ON public.outfits(created_at);
CREATE INDEX IF NOT EXISTS idx_user_outfit_likes_user_id ON public.user_outfit_likes(user_id);
CREATE INDEX IF NOT EXISTS idx_user_outfit_dislikes_user_id ON public.user_outfit_dislikes(user_id);
CREATE INDEX IF NOT EXISTS idx_user_product_likes_user_id ON public.user_product_likes(user_id);
CREATE INDEX IF NOT EXISTS idx_user_product_dislikes_user_id ON public.user_product_dislikes(user_id);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================
-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.outfits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.product_outfit_junction ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_outfit_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_outfit_dislikes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_product_likes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.user_product_dislikes ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- PROFILES TABLE POLICIES
-- ============================================================================
-- Users can only see and edit their own profile
CREATE POLICY "Users can view own profile" ON public.profiles
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Users can insert own profile" ON public.profiles
    FOR INSERT WITH CHECK (auth.uid() = id);

-- ============================================================================
-- PRODUCTS TABLE POLICIES
-- ============================================================================
-- Products are readable by all authenticated users
CREATE POLICY "Products are viewable by authenticated users" ON public.products
    FOR SELECT USING (auth.role() = 'authenticated');

-- Only service role can insert/update products (for backend operations)
CREATE POLICY "Service role can manage products" ON public.products
    FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- OUTFITS TABLE POLICIES
-- ============================================================================
-- Outfits are readable by all authenticated users
CREATE POLICY "Outfits are viewable by authenticated users" ON public.outfits
    FOR SELECT USING (auth.role() = 'authenticated');

-- Only service role can insert/update outfits (for backend operations)
CREATE POLICY "Service role can manage outfits" ON public.outfits
    FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- JUNCTION TABLE POLICIES
-- ============================================================================
-- Product-Outfit junction: readable by all, manageable by service role
CREATE POLICY "Product outfit junction viewable by authenticated users" ON public.product_outfit_junction
    FOR SELECT USING (auth.role() = 'authenticated');

CREATE POLICY "Service role can manage product outfit junction" ON public.product_outfit_junction
    FOR ALL USING (auth.role() = 'service_role');

-- ============================================================================
-- USER INTERACTION POLICIES
-- ============================================================================
-- User outfit likes: users can only manage their own likes
CREATE POLICY "Users can view own outfit likes" ON public.user_outfit_likes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own outfit likes" ON public.user_outfit_likes
    FOR ALL USING (auth.uid() = user_id);

-- User outfit dislikes: users can only manage their own dislikes
CREATE POLICY "Users can view own outfit dislikes" ON public.user_outfit_dislikes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own outfit dislikes" ON public.user_outfit_dislikes
    FOR ALL USING (auth.uid() = user_id);

-- User product likes: users can only manage their own likes
CREATE POLICY "Users can view own product likes" ON public.user_product_likes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own product likes" ON public.user_product_likes
    FOR ALL USING (auth.uid() = user_id);

-- User product dislikes: users can only manage their own dislikes
CREATE POLICY "Users can view own product dislikes" ON public.user_product_dislikes
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can manage own product dislikes" ON public.user_product_dislikes
    FOR ALL USING (auth.uid() = user_id);

-- ============================================================================
-- TRIGGERS AND FUNCTIONS
-- ============================================================================
-- Function to automatically update updated_at timestamp
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for profiles table
CREATE TRIGGER handle_updated_at_profiles
    BEFORE UPDATE ON public.profiles
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- ============================================================================
-- COMMENTS FOR DOCUMENTATION
-- ============================================================================
COMMENT ON TABLE public.profiles IS 'User profiles linked to Supabase Auth users with fashion preferences';
COMMENT ON TABLE public.products IS 'Product catalog from various shopping brands';
COMMENT ON TABLE public.outfits IS 'Generated outfit concepts with styling information';
COMMENT ON TABLE public.product_outfit_junction IS 'Many-to-many relationship between products and outfits';
COMMENT ON TABLE public.user_outfit_likes IS 'User likes for outfit concepts';
COMMENT ON TABLE public.user_outfit_dislikes IS 'User dislikes for outfit concepts';
COMMENT ON TABLE public.user_product_likes IS 'User likes for individual products';
COMMENT ON TABLE public.user_product_dislikes IS 'User dislikes for individual products';

COMMENT ON COLUMN public.profiles.preferred_brands IS 'Array of brand names the user prefers';
COMMENT ON COLUMN public.products.images IS 'Array of image URLs for the product';
COMMENT ON COLUMN public.products.price IS 'Product price as text to handle various formats and currencies';
